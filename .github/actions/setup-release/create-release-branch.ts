import type * as core from "@actions/core";
import type * as exec from "@actions/exec";
import type { Context } from "@actions/github/lib/context";
import type { GitHub } from "@actions/github/lib/utils";
import type { AsyncFunctionArguments } from "../shared/types.js";

/**
 * Create release branch result
 */
interface CreateReleaseBranchResult {
	/** Whether the branch was created */
	created: boolean;
	/** PR number if PR was created */
	prNumber: number | null;
	/** GitHub check run ID */
	checkId: number;
	/** Version summary */
	versionSummary: string;
}

/**
 * Executes a command with retry logic and exponential backoff
 *
 * @param core - GitHub Actions core module
 * @param exec - GitHub Actions exec module
 * @param command - Command to execute
 * @param args - Command arguments
 * @param options - Exec options
 * @param maxRetries - Maximum number of retries (default: 3)
 * @returns Promise that resolves when command succeeds
 */
async function execWithRetry(
	coreModule: typeof core,
	execModule: typeof exec,
	command: string,
	args: string[],
	options: exec.ExecOptions = {},
	maxRetries: number = 3,
): Promise<void> {
	const retryableErrors = ["ECONNRESET", "ETIMEDOUT", "ENOTFOUND", "EAI_AGAIN"];
	const baseDelay = 1000;
	const maxDelay = 10000;

	for (let attempt = 0; attempt <= maxRetries; attempt++) {
		try {
			await execModule.exec(command, args, options);
			return;
		} catch (error) {
			const isLastAttempt = attempt === maxRetries;
			/* v8 ignore next -- @preserve - Defensive: handles non-Error throws (extremely rare) */
			const errorMessage = error instanceof Error ? error.message : String(error);
			const isRetryable = retryableErrors.some((err) => errorMessage.includes(err));

			if (isLastAttempt || !isRetryable) {
				throw error;
			}

			// Exponential backoff with jitter
			const delay = Math.min(baseDelay * 2 ** attempt + Math.random() * 1000, maxDelay);
			coreModule.warning(`Attempt ${attempt + 1} failed: ${errorMessage}. Retrying in ${Math.round(delay)}ms...`);

			await new Promise((resolve) => setTimeout(resolve, delay));
		}
	}
}

/**
 * Creates the release branch and PR
 *
 * @param core - GitHub Actions core module
 * @param exec - GitHub Actions exec module
 * @param github - GitHub API client
 * @param context - GitHub Actions context
 * @param releaseBranch - Release branch name
 * @param targetBranch - Target branch for PR
 * @param packageManager - Package manager to use
 * @param versionCommand - Custom version command
 * @param prTitlePrefix - Prefix for PR title
 * @param dryRun - Whether this is a dry-run
 * @returns Create release branch result
 */
async function createReleaseBranch(
	coreModule: typeof core,
	execModule: typeof exec,
	github: InstanceType<typeof GitHub>,
	context: Context,
	releaseBranch: string,
	targetBranch: string,
	packageManager: string,
	versionCommand: string,
	prTitlePrefix: string,
	dryRun: boolean,
): Promise<CreateReleaseBranchResult> {
	const core = coreModule;
	const exec = execModule;

	core.startGroup("Creating release branch");

	// Configure git
	await exec.exec("git", ["config", "user.name", "github-actions[bot]"]);
	await exec.exec("git", ["config", "user.email", "github-actions[bot]@users.noreply.github.com"]);

	// Create and checkout release branch from target branch HEAD
	core.info(`Creating branch '${releaseBranch}' from '${targetBranch}' HEAD`);
	if (!dryRun) {
		await exec.exec("git", ["checkout", "-b", releaseBranch, `origin/${targetBranch}`]);
	} else {
		core.info(`[DRY RUN] Would create branch: ${releaseBranch} from origin/${targetBranch}`);
	}

	// Run changeset version
	core.info("Running changeset version");
	const versionCmd =
		versionCommand || (packageManager === "pnpm" ? "pnpm" : packageManager === "yarn" ? "yarn" : "npm");
	const versionArgs =
		versionCommand === ""
			? packageManager === "pnpm"
				? ["ci:version"]
				: packageManager === "yarn"
					? ["ci:version"]
					: ["run", "ci:version"]
			: versionCommand.split(" ");

	if (!dryRun) {
		await execWithRetry(coreModule, execModule, versionCmd, versionArgs);
	} else {
		core.info(`[DRY RUN] Would run: ${versionCmd} ${versionArgs.join(" ")}`);
	}

	// Check for changes
	let hasChanges = false;
	let changedFiles = "";

	if (!dryRun) {
		await exec.exec("git", ["status", "--porcelain"], {
			listeners: {
				stdout: (data: Buffer) => {
					changedFiles += data.toString();
				},
			},
		});
		hasChanges = changedFiles.trim().length > 0;
	} else {
		// In dry-run mode, assume changes exist
		hasChanges = true;
		core.info("[DRY RUN] Assuming changes exist for version bump");
	}

	if (!hasChanges) {
		core.info("No changes generated by changeset version. Cleaning up and exiting.");
		if (!dryRun) {
			await exec.exec("git", ["checkout", targetBranch]);
			await exec.exec("git", ["branch", "-D", releaseBranch]);
		}
		core.endGroup();

		// Create check run for no changes
		const { data: checkRun } = await github.rest.checks.create({
			owner: context.repo.owner,
			repo: context.repo.repo,
			name: dryRun ? "ðŸ§ª Create Release Branch (Dry Run)" : "Create Release Branch",
			head_sha: context.sha,
			status: "completed",
			conclusion: "neutral",
			output: {
				title: "No version changes generated",
				summary: "Changeset version command did not produce any changes. No release branch created.",
			},
		});

		// Write job summary
		await core.summary
			.addHeading(dryRun ? "ðŸ§ª Create Release Branch (Dry Run)" : "Create Release Branch", 2)
			.addRaw("No version changes generated")
			.addEOL()
			.addRaw("Changeset version command did not produce any changes. No release branch created.")
			.write();

		return {
			created: false,
			prNumber: null,
			checkId: checkRun.id,
			versionSummary: "No changes",
		};
	}

	// Generate version summary from changed files
	const versionSummary = changedFiles
		.split("\n")
		.filter((line) => line.includes("package.json") || line.includes("CHANGELOG.md"))
		.join("\n");

	core.info("Version changes:");
	core.info(versionSummary);

	// Commit changes
	const commitMessage = `${prTitlePrefix}\n\nVersion bump from changesets`;
	if (!dryRun) {
		await exec.exec("git", ["add", "."]);
		await exec.exec("git", ["commit", "-m", commitMessage]);
	} else {
		core.info(`[DRY RUN] Would commit with message: ${commitMessage}`);
	}

	// Push branch with retry
	core.info(`Pushing branch '${releaseBranch}' to origin`);
	if (!dryRun) {
		await execWithRetry(core, exec, "git", ["push", "-u", "origin", releaseBranch]);
	} else {
		core.info(`[DRY RUN] Would push branch: ${releaseBranch}`);
	}

	core.endGroup();

	// Create PR with retry
	core.startGroup("Creating pull request");

	let prNumber: number | null = null;
	let prUrl = "";

	const prTitle = `${prTitlePrefix}`;

	// Build PR body using core.summary methods
	const prBodyBuilder = core.summary
		.addHeading("Release PR", 2)
		.addEOL()
		.addRaw("This PR was automatically generated by the release workflow.")
		.addEOL()
		.addEOL()
		.addHeading("Version Changes", 3)
		.addEOL()
		.addCodeBlock(versionSummary, "text")
		.addEOL();

	if (dryRun) {
		prBodyBuilder.addEOL().addRaw("---").addEOL().addRaw("**Mode**: Dry Run (Preview Only)").addEOL();
	}

	prBodyBuilder
		.addEOL()
		.addRaw("---")
		.addEOL()
		.addRaw(
			`ðŸ¤– Generated with [GitHub Actions](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`,
		);

	const prBody = prBodyBuilder.stringify();

	if (!dryRun) {
		try {
			const { data: pr } = await github.rest.pulls.create({
				owner: context.repo.owner,
				repo: context.repo.repo,
				title: prTitle,
				head: releaseBranch,
				base: targetBranch,
				body: prBody,
			});

			prNumber = pr.number;
			prUrl = pr.html_url;

			// Add labels
			await github.rest.issues.addLabels({
				owner: context.repo.owner,
				repo: context.repo.repo,
				issue_number: prNumber,
				labels: ["automated", "release"],
			});

			core.info(`âœ“ Created PR #${prNumber}: ${prUrl}`);
		} catch (error) {
			// Retry PR creation once after brief delay
			core.warning(`PR creation failed, retrying: ${error instanceof Error ? error.message : String(error)}`);
			await new Promise((resolve) => setTimeout(resolve, 2000));

			const { data: pr } = await github.rest.pulls.create({
				owner: context.repo.owner,
				repo: context.repo.repo,
				title: prTitle,
				head: releaseBranch,
				base: targetBranch,
				body: prBody,
			});

			prNumber = pr.number;
			prUrl = pr.html_url;

			await github.rest.issues.addLabels({
				owner: context.repo.owner,
				repo: context.repo.repo,
				issue_number: prNumber,
				labels: ["automated", "release"],
			});

			core.info(`âœ“ Created PR #${prNumber}: ${prUrl}`);
		}
	} else {
		core.info(`[DRY RUN] Would create PR with title: ${prTitle}`);
		core.info(`[DRY RUN] PR body:\n${prBody}`);
	}

	core.endGroup();

	// Build check details using core.summary methods
	const checkSummaryBuilder = core.summary
		.addHeading("Release Branch Created", 2)
		.addEOL()
		.addTable([
			[
				{ data: "Property", header: true },
				{ data: "Value", header: true },
			],
			["Branch", `\`${releaseBranch}\``],
			["Target", `\`${targetBranch}\``],
			["PR", prNumber ? `[#${prNumber}](${prUrl})` : "_N/A (dry run)_"],
		])
		.addEOL()
		.addHeading("Version Changes", 3)
		.addEOL()
		.addCodeBlock(versionSummary, "text");

	if (dryRun) {
		checkSummaryBuilder.addEOL().addRaw("---").addEOL().addRaw("**Mode**: Dry Run (Preview Only)");
	}

	const checkDetails = checkSummaryBuilder.stringify();

	const { data: checkRun } = await github.rest.checks.create({
		owner: context.repo.owner,
		repo: context.repo.repo,
		name: dryRun ? "ðŸ§ª Create Release Branch (Dry Run)" : "Create Release Branch",
		head_sha: context.sha,
		status: "completed",
		conclusion: "success",
		output: {
			title: prNumber ? `Created release PR #${prNumber}` : "Release branch created (dry run)",
			summary: checkDetails,
		},
	});

	// Write job summary
	await core.summary
		.addHeading(dryRun ? "ðŸ§ª Create Release Branch (Dry Run)" : "Create Release Branch", 2)
		.addRaw(prNumber ? `Created release PR #${prNumber}` : "Release branch created (dry run)")
		.addEOL()
		.addHeading("Release Branch Created", 3)
		.addTable([
			[
				{ data: "Property", header: true },
				{ data: "Value", header: true },
			],
			["Branch", `\`${releaseBranch}\``],
			["Target", `\`${targetBranch}\``],
			["PR", prNumber ? `#${prNumber}` : "_N/A (dry run)_"],
		])
		.addHeading("Version Changes", 3)
		.addCodeBlock(versionSummary, "text")
		.write();

	return {
		created: true,
		prNumber,
		checkId: checkRun.id,
		versionSummary,
	};
}

/**
 * Main action entrypoint: Creates release branch and PR, sets GitHub Actions outputs
 *
 * @param args - Function arguments from github-script
 * @param args.core - GitHub Actions core module
 * @param args.exec - GitHub Actions exec module
 * @param args.github - GitHub API client
 * @param args.context - GitHub Actions context
 *
 * @remarks
 * This action creates the release branch, runs changeset version, and creates a PR.
 * It sets the following outputs:
 * - `created`: Whether the branch was created (true | false)
 * - `pr_number`: PR number if PR was created (number | empty string)
 * - `check_id`: GitHub check run ID
 * - `version_summary`: Summary of version changes
 *
 * The action respects environment variables:
 * - `RELEASE_BRANCH`: Release branch name (default: changeset-release/main)
 * - `TARGET_BRANCH`: Target branch for PR (default: main)
 * - `PACKAGE_MANAGER`: Package manager to use (default: pnpm)
 * - `VERSION_COMMAND`: Custom version command (default: empty, uses package manager default)
 * - `PR_TITLE_PREFIX`: Prefix for PR title (default: chore: release)
 * - `DRY_RUN`: Whether this is a dry-run (true | false)
 *
 * @example
 * ```yaml
 * - uses: actions/github-script@v8
 *   env:
 *     RELEASE_BRANCH: changeset-release/main
 *     TARGET_BRANCH: main
 *     PACKAGE_MANAGER: ${{ steps.detect-repo-type.outputs.package-manager }}
 *     VERSION_COMMAND: ""
 *     PR_TITLE_PREFIX: "chore: release"
 *     DRY_RUN: ${{ inputs.dry_run }}
 *   with:
 *     script: |
 *       const { default: createReleaseBranch } = await import('${{ github.workspace }}/.github/actions/setup-release/create-release-branch.ts');
 *       await createReleaseBranch({ core, exec, github, context });
 * ```
 */
export default async ({ core, exec, github, context }: AsyncFunctionArguments): Promise<void> => {
	try {
		const releaseBranch = process.env.RELEASE_BRANCH || "changeset-release/main";
		const targetBranch = process.env.TARGET_BRANCH || "main";
		const packageManager = process.env.PACKAGE_MANAGER || "pnpm";
		const versionCommand = process.env.VERSION_COMMAND || "";
		const prTitlePrefix = process.env.PR_TITLE_PREFIX || "chore: release";
		const dryRun = process.env.DRY_RUN === "true";

		if (dryRun) {
			core.notice("ðŸ§ª Running in dry-run mode (preview only)");
		}

		const result = await createReleaseBranch(
			core,
			exec,
			github,
			context,
			releaseBranch,
			targetBranch,
			packageManager,
			versionCommand,
			prTitlePrefix,
			dryRun,
		);

		// Set outputs
		core.setOutput("created", result.created.toString());
		core.setOutput("pr_number", result.prNumber !== null ? result.prNumber.toString() : "");
		core.setOutput("check_id", result.checkId.toString());
		core.setOutput("version_summary", result.versionSummary);

		// Log summary
		if (result.created) {
			if (result.prNumber) {
				core.notice(`âœ“ Created release branch '${releaseBranch}' with PR #${result.prNumber}`);
			} else {
				core.notice(`âœ“ Created release branch '${releaseBranch}' (dry run, no PR)`);
			}
		} else {
			core.notice(`âœ“ No changes generated, release branch not created`);
		}

		// Debug outputs
		core.debug(`Set output 'created' to: ${result.created}`);
		core.debug(`Set output 'pr_number' to: ${result.prNumber !== null ? result.prNumber : ""}`);
		core.debug(`Set output 'check_id' to: ${result.checkId}`);
		core.debug(`Set output 'version_summary' to: ${result.versionSummary}`);
	} catch (error) {
		/* v8 ignore next -- @preserve */
		core.setFailed(`Failed to create release branch: ${error instanceof Error ? error.message : String(error)}`);
	}
};
