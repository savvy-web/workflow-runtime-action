name: Pull Request

on:
  pull_request:
    branches: [main, changeset-release/main]
    types: [opened, synchronize, reopened, edited]

# Cancel previous runs on new pushes to the same branch or PR
# When cancelled, the cleanup-checks job will resolve any in-progress checks as neutral
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

# Default permissions (most restrictive - jobs override as needed)
permissions:
  contents: read

jobs:
  validate:
    name: Validation
    runs-on: ubuntu-latest
    # Pre-declare environment variables for check IDs (set dynamically by create-checks step)
    env:
      DO_NOT_TRACK: "1"
      TURBO_TELEMETRY_DISABLE: "1"
      PR_TITLE_CHECK_ID: ""
      COMMITLINT_CHECK_ID: ""
      LINT_CHECK_ID: ""
      TEST_CHECK_ID: ""
    outputs:
      pr-title-result: ${{ steps.checks.outputs.pr-title-result }}
      commitlint-result: ${{ steps.checks.outputs.commitlint-result }}
      commitlint-warnings-only: ${{ steps.commitlint-check.outputs.warnings_only }}
      lint-result: ${{ steps.checks.outputs.lint-result }}
      test-result: ${{ steps.checks.outputs.test-result }}
    permissions:
      contents: read
      checks: write
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          permission-contents: read
          permission-checks: write

      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}
          persist-credentials: true

      # Create all validation checks upfront so they appear in PR immediately
      # Sets env vars: PR_TITLE_CHECK_ID, COMMITLINT_CHECK_ID, LINT_CHECK_ID, TEST_CHECK_ID
      - name: Create validation checks
        id: create-checks
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const checks = [
              {
                name: 'PR Title Validation',
                title: 'Validating PR title...',
                summary: 'Checking if PR title follows conventional commit format',
                env_key: 'PR_TITLE_CHECK_ID'
              },
              {
                name: 'Conventional Commits',
                title: 'Validating commit messages...',
                summary: 'Checking if all commit messages follow conventional commit format',
                env_key: 'COMMITLINT_CHECK_ID'
              },
              {
                name: 'Code Quality',
                title: 'Running linter...',
                summary: 'Checking code quality with Biome',
                env_key: 'LINT_CHECK_ID'
              },
              {
                name: 'Tests',
                title: 'Running tests...',
                summary: 'Executing test suite',
                env_key: 'TEST_CHECK_ID'
              }
            ];

            for (const check of checks) {
              const { data: createdCheck } = await github.rest.checks.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head_sha: context.payload.pull_request.head.sha,
                name: check.name,
                status: 'in_progress',
                output: {
                  title: check.title,
                  summary: check.summary
                }
              });
              if (!createdCheck.id) {
                core.setFailed(`Failed to create check: ${check.name}`);
              }
              core.exportVariable(check.env_key, createdCheck.id);
            }

      - name: Detect runtime
        id: detect-runtime
        uses: ./.github/actions/detect-runtime

      - name: Validate runtime
        if: steps.detect-runtime.outputs.runtime != 'node'
        run: |
          echo "::error::Unsupported runtime: ${{ steps.detect-runtime.outputs.runtime }}"
          echo "::error::This workflow only supports Node.js runtime. Detected: ${{ steps.detect-runtime.outputs.runtime }}"
          exit 1

      - name: Setup Node.js and dependencies
        id: setup-node
        if: steps.detect-runtime.outputs.runtime == 'node'
        uses: ./.github/actions/node
        with:
          package-manager: ${{ steps.detect-runtime.outputs.package-manager }}

      - name: Setup Biome
        uses: ./.github/actions/biome

      - name: Fetch base branch for comparison
        run: git fetch origin ${{ github.base_ref }}

      - name: Validate PR Title
        id: pr-title-check
        continue-on-error: true
        run: |
          echo "Validating PR title: ${{ github.event.pull_request.title }}"
          set +e
          pnpm exec commitlint --config commitlint.config.ts <<< "${{ github.event.pull_request.title }}"
          EXIT_CODE=$?
          set -e
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT
          exit 0

      - name: Update PR Title Check
        if: always()
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // Retry helper for transient GitHub API errors
            async function updateCheckWithRetry(updateParams, maxRetries = 5) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await github.rest.checks.update(updateParams);
                } catch (error) {
                  const is500Error = error.status >= 500 && error.status < 600;
                  const shouldRetry = is500Error && attempt < maxRetries;

                  if (shouldRetry) {
                    const delayMs = Math.min(1000 * Math.pow(2, attempt - 1), 16000);
                    console.log(`Attempt ${attempt} failed with ${error.status} error. Retrying in ${delayMs}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                  } else {
                    throw error;
                  }
                }
              }
            }

            const exitCode = '${{ steps.pr-title-check.outputs.exit_code }}';
            const conclusion = exitCode === '0' ? 'success' : 'failure';

            await updateCheckWithRetry({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: '${{ env.PR_TITLE_CHECK_ID }}',
              status: 'completed',
              conclusion: conclusion,
              output: {
                title: conclusion === 'success' ? 'PR title is valid' : 'PR title is invalid',
                summary: conclusion === 'success'
                  ? 'PR title follows conventional commit format'
                  : 'PR title must follow conventional commit format (e.g., "feat: add feature")'
              }
            });

      # Commitlint Validation
      - name: Validate Conventional Commits
        id: commitlint-check
        continue-on-error: true
        run: |
          echo "Validating commit messages between origin/${{ github.base_ref }} and HEAD using @savvy-web/commitlint-config"

          set +e
          pnpm exec commitlint --from=origin/${{ github.base_ref }} --to=HEAD --config commitlint.config.ts --verbose > commitlint-results.txt 2>&1
          COMMITLINT_EXIT_CODE=$?
          set -e

          # Parse results and create GitHub annotations
          node .github/scripts/commitlint-annotate.js

          echo "exit_code=$COMMITLINT_EXIT_CODE" >> $GITHUB_OUTPUT
          exit 0

      - name: Update Commitlint Check
        if: always()
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // Retry helper for transient GitHub API errors
            async function updateCheckWithRetry(updateParams, maxRetries = 5) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await github.rest.checks.update(updateParams);
                } catch (error) {
                  const is500Error = error.status >= 500 && error.status < 600;
                  const shouldRetry = is500Error && attempt < maxRetries;

                  if (shouldRetry) {
                    const delayMs = Math.min(1000 * Math.pow(2, attempt - 1), 16000);
                    console.log(`Attempt ${attempt} failed with ${error.status} error. Retrying in ${delayMs}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                  } else {
                    throw error;
                  }
                }
              }
            }

            const exitCode = '${{ steps.commitlint-check.outputs.exit_code }}';
            const warningsOnly = '${{ steps.commitlint-check.outputs.warnings_only }}' === 'true';

            let conclusion = 'success';
            let title = 'All commits are valid';
            let summary = 'All commit messages follow conventional commit format';

            if (warningsOnly) {
              conclusion = 'neutral';
              title = 'Commits have warnings';
              summary = `Found warning(s) in commit messages. Consider addressing these for better commit hygiene.`;
            } else if (exitCode !== '0') {
              conclusion = 'failure';
              title = 'Commits have errors';
              summary = 'Some commit messages do not follow conventional commit format. Check the workflow logs for details.';
            }

            await updateCheckWithRetry({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: '${{ env.COMMITLINT_CHECK_ID }}',
              status: 'completed',
              conclusion: conclusion,
              output: { title, summary }
            });

      # Lint Validation
      - name: Run Biome Lint
        id: lint-check
        continue-on-error: true
        run: |
          set +e
          biome ci .
          echo "exit_code=$?" >> $GITHUB_OUTPUT
          exit 0

      - name: Update Lint Check
        if: always()
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // Retry helper for transient GitHub API errors
            async function updateCheckWithRetry(updateParams, maxRetries = 5) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await github.rest.checks.update(updateParams);
                } catch (error) {
                  const is500Error = error.status >= 500 && error.status < 600;
                  const shouldRetry = is500Error && attempt < maxRetries;

                  if (shouldRetry) {
                    const delayMs = Math.min(1000 * Math.pow(2, attempt - 1), 16000);
                    console.log(`Attempt ${attempt} failed with ${error.status} error. Retrying in ${delayMs}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                  } else {
                    throw error;
                  }
                }
              }
            }

            const exitCode = '${{ steps.lint-check.outputs.exit_code }}';
            const conclusion = exitCode === '0' ? 'success' : 'failure';

            await updateCheckWithRetry({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: '${{ env.LINT_CHECK_ID }}',
              status: 'completed',
              conclusion: conclusion,
              output: {
                title: conclusion === 'success' ? 'Code quality checks passed' : 'Code quality checks failed',
                summary: conclusion === 'success'
                  ? 'All Biome checks passed'
                  : 'Biome found issues. Check the workflow logs for details.'
              }
            });

      - name: Run Tests
        id: test-check
        continue-on-error: true
        run: |
          set +e
          # Run tests through Turbo - automatically runs typecheck:all first
          # vitest.config.ts handles GitHub Actions reporter configuration
          pnpm ci:test
          EXIT_CODE=$?
          set -e

          # Add test results to job summary
          echo "## Test Results" >> $GITHUB_STEP_SUMMARY
          if [ $EXIT_CODE -eq 0 ]; then
            echo "‚úÖ All tests passed!" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Some tests failed. Check the logs above for details." >> $GITHUB_STEP_SUMMARY
          fi

          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT
          exit 0

      - name: Update Test Check
        if: always()
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // Retry helper for transient GitHub API errors
            async function updateCheckWithRetry(updateParams, maxRetries = 5) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await github.rest.checks.update(updateParams);
                } catch (error) {
                  const is500Error = error.status >= 500 && error.status < 600;
                  const shouldRetry = is500Error && attempt < maxRetries;

                  if (shouldRetry) {
                    const delayMs = Math.min(1000 * Math.pow(2, attempt - 1), 16000);
                    console.log(`Attempt ${attempt} failed with ${error.status} error. Retrying in ${delayMs}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                  } else {
                    throw error;
                  }
                }
              }
            }

            const exitCode = '${{ steps.test-check.outputs.exit_code }}';
            const conclusion = exitCode === '0' ? 'success' : 'failure';

            await updateCheckWithRetry({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: '${{ env.TEST_CHECK_ID }}',
              status: 'completed',
              conclusion: conclusion,
              output: {
                title: conclusion === 'success' ? 'All tests passed' : 'Some tests failed',
                summary: conclusion === 'success'
                  ? 'All test suites passed'
                  : 'Some tests failed. Check the workflow logs for details.'
              }
            });

      # Set outputs for downstream jobs
      - name: Set check outputs
        id: checks
        if: always()
        run: |
          # PR Title result
          if [ "${{ steps.pr-title-check.outputs.exit_code }}" == "0" ]; then
            echo "pr-title-result=success" >> $GITHUB_OUTPUT
          else
            echo "pr-title-result=failure" >> $GITHUB_OUTPUT
          fi

          # Commitlint result (with warnings-only support)
          if [ "${{ steps.commitlint-check.outputs.exit_code }}" == "0" ]; then
            echo "commitlint-result=success" >> $GITHUB_OUTPUT
          elif [ "${{ steps.commitlint-check.outputs.warnings_only }}" == "true" ]; then
            echo "commitlint-result=neutral" >> $GITHUB_OUTPUT
          else
            echo "commitlint-result=failure" >> $GITHUB_OUTPUT
          fi

          # Lint result
          if [ "${{ steps.lint-check.outputs.exit_code }}" == "0" ]; then
            echo "lint-result=success" >> $GITHUB_OUTPUT
          else
            echo "lint-result=failure" >> $GITHUB_OUTPUT
          fi

          # Test result
          if [ "${{ steps.test-check.outputs.exit_code }}" == "0" ]; then
            echo "test-result=success" >> $GITHUB_OUTPUT
          else
            echo "test-result=failure" >> $GITHUB_OUTPUT
          fi

  claude-review:
    name: Claude Code Review
    needs: [validate]
    runs-on: ubuntu-latest
    # Only run for human users or the bot (skip other bots like dependabot, renovate, etc.)
    if: |
      github.event.pull_request.user.login == '${{ vars.APP_BOT_NAME }}' ||
      github.event.pull_request.user.type == 'User'
    env:
      CHECK_RUN_ID: ""
      CLAUDE_COMMENT_ID: "0"
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read # Required for Claude to read CI results on PRs
      checks: write # Required to create/update/read checks
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          permission-actions: read
          permission-contents: write
          permission-pull-requests: write
          permission-issues: write
          permission-checks: write
          permission-statuses: write

      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}
          persist-credentials: true

      - name: Check if PR only contains version/changelog changes
        id: check-changes
        run: |
          # Get list of changed files
          git fetch origin ${{ github.base_ref }}

          # Get list of changed files with their status
          CHANGED_FILES_WITH_STATUS=$(git diff --name-status origin/${{ github.base_ref }}...HEAD)
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)

          echo "::group::Changed files"
          echo "$CHANGED_FILES"
          echo "::endgroup::"

          # Initialize counters for summary
          TOTAL_FILES=0
          SKIPPABLE_FILES=0
          VERSION_ONLY_FILES=""
          CHANGELOG_FILES=""
          DELETED_CHANGESET_FILES=""
          NON_SKIPPABLE_FILES=""

          # Check if all changes are only package.json version updates, CHANGELOG.md files, or deleted changeset files
          SKIP_REVIEW=true

          for file in $CHANGED_FILES; do
              TOTAL_FILES=$((TOTAL_FILES + 1))

              if [[ "$file" == "CHANGELOG.md" || "$file" == *"/CHANGELOG.md" ]]; then
                  # CHANGELOG files are okay to skip
                  echo "‚úì $file - CHANGELOG file (skippable)"
                  CHANGELOG_FILES="${CHANGELOG_FILES}- ${file}\n"
                  SKIPPABLE_FILES=$((SKIPPABLE_FILES + 1))
                  continue
              elif [[ "$file" == ".changeset/"*.md ]]; then
                  # Check if changeset markdown files are only being deleted
                  if echo "$CHANGED_FILES_WITH_STATUS" | grep -E "^D[[:space:]]+$(echo "$file" | sed 's/[[\.*^$()+?{|]/\\&/g')$" > /dev/null; then
                      # File is deleted, okay to skip
                      echo "‚úì $file - Deleted changeset file (skippable)"
                      DELETED_CHANGESET_FILES="${DELETED_CHANGESET_FILES}- ${file}\n"
                      SKIPPABLE_FILES=$((SKIPPABLE_FILES + 1))
                      continue
                  else
                      # Changeset file is added or modified, should review
                      echo "‚úó $file - Added/modified changeset file (requires review)"
                      NON_SKIPPABLE_FILES="${NON_SKIPPABLE_FILES}- ${file} (changeset addition/modification)\n"
                      SKIP_REVIEW=false
                      break
                  fi
              elif [[ "$file" == "package.json" || "$file" == *"/package.json" ]]; then
                  # Check if package.json only has version changes
                  DIFF=$(git diff origin/${{ github.base_ref }}...HEAD -- "$file")
                  # Check for non-version changes (excluding diff headers)
                  NON_VERSION_CHANGES=$(echo "$DIFF" | grep -E '^\+|^-' | grep -v '^+++\|^---' | grep -v '"version":' || true)

                  if [ -z "$NON_VERSION_CHANGES" ]; then
                      # Only version changes
                      echo "‚úì $file - Package.json with version-only changes (skippable)"
                      VERSION_ONLY_FILES="${VERSION_ONLY_FILES}- ${file}\n"
                      SKIPPABLE_FILES=$((SKIPPABLE_FILES + 1))
                  else
                      # There are changes other than version
                      echo "‚úó $file - Package.json with non-version changes (requires review)"
                      NON_SKIPPABLE_FILES="${NON_SKIPPABLE_FILES}- ${file} (non-version changes in package.json)\n"
                      SKIP_REVIEW=false
                      break
                  fi
              else
                  # Any other file type means we should review
                  echo "‚úó $file - Other file type (requires review)"
                  NON_SKIPPABLE_FILES="${NON_SKIPPABLE_FILES}- ${file} (non-release file)\n"
                  SKIP_REVIEW=false
                  break
              fi
          done

          # Create GitHub Actions summary
          echo "## Claude Review Skip Check Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Total files changed:** $TOTAL_FILES" >> $GITHUB_STEP_SUMMARY
          echo "**Skippable files:** $SKIPPABLE_FILES" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -n "$VERSION_ONLY_FILES" ]; then
              echo "### ‚úÖ Version-only package.json files" >> $GITHUB_STEP_SUMMARY
              echo -e "$VERSION_ONLY_FILES" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -n "$CHANGELOG_FILES" ]; then
              echo "### ‚úÖ CHANGELOG files" >> $GITHUB_STEP_SUMMARY
              echo -e "$CHANGELOG_FILES" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -n "$DELETED_CHANGESET_FILES" ]; then
              echo "### ‚úÖ Deleted changeset files" >> $GITHUB_STEP_SUMMARY
              echo -e "$DELETED_CHANGESET_FILES" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -n "$NON_SKIPPABLE_FILES" ]; then
              echo "### ‚ùå Files requiring review" >> $GITHUB_STEP_SUMMARY
              echo -e "$NON_SKIPPABLE_FILES" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "$SKIP_REVIEW" = "true" ]; then
              echo "**Decision: ‚úÖ Skipping Claude review** - PR only contains version bumps, changelog updates, and/or deleted changeset files" >> $GITHUB_STEP_SUMMARY
          else
              echo "**Decision: üîç Running Claude review** - PR contains substantive changes requiring review" >> $GITHUB_STEP_SUMMARY
          fi

          # Set output
          echo "skip-review=$SKIP_REVIEW" >> $GITHUB_OUTPUT

          # Log final decision
          echo ""
          if [ "$SKIP_REVIEW" = "true" ]; then
              echo "====================================="
              echo "DECISION: Skipping Claude review"
              echo "====================================="
          else
              echo "====================================="
              echo "DECISION: Running Claude review"
              echo "====================================="
          fi

      - name: Create Claude Review check
        id: create-check
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const shouldSkip = '${{ steps.check-changes.outputs.skip-review }}' === 'true';

            // Build check run parameters
            const params = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'Claude Code Review',
              head_sha: context.payload.pull_request.head.sha,
              status: shouldSkip ? 'completed' : 'queued',
              output: {
                title: shouldSkip ? 'Review skipped' : 'Waiting for validation...',
                summary: shouldSkip
                  ? 'Pull request only contains version bumps, changelog updates, and/or deleted changeset files. No code review needed.'
                  : 'Claude Code Review is waiting for validation checks to complete before starting the review.'
              }
            };

            // Only include conclusion if status is completed
            if (shouldSkip) {
              params.conclusion = 'neutral';
            }

            const { data: checkRun } = await github.rest.checks.create(params);

            if (!checkRun.id) {
              core.setFailed('Failed to create Claude Code Review check');
            }
            core.exportVariable('CHECK_RUN_ID', checkRun.id);
            console.log(`Created check run ${checkRun.id}`);

      - name: Update check - Starting review
        if: steps.check-changes.outputs.skip-review != 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // Retry helper for transient GitHub API errors
            async function updateCheckWithRetry(updateParams, maxRetries = 5) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await github.rest.checks.update(updateParams);
                } catch (error) {
                  const is500Error = error.status >= 500 && error.status < 600;
                  const shouldRetry = is500Error && attempt < maxRetries;

                  if (shouldRetry) {
                    const delayMs = Math.min(1000 * Math.pow(2, attempt - 1), 16000);
                    console.log(`Attempt ${attempt} failed with ${error.status} error. Retrying in ${delayMs}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                  } else {
                    throw error;
                  }
                }
              }
            }

            const checkRunId = process.env.CHECK_RUN_ID;
            await updateCheckWithRetry({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: checkRunId,
              status: 'in_progress',
              output: {
                title: 'Reviewing code...',
                summary: 'Claude Code Review is analyzing the pull request changes.'
              }
            });

      - name: Find existing Claude review comment
        if: steps.check-changes.outputs.skip-review != 'true'
        id: find-comment
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number
            });

            // Look for existing Claude review comment (sticky comment)
            const botName = '${{ vars.APP_BOT_NAME }}';
            const claudeComment = comments.find(comment =>
              comment.user.login === botName &&
              (comment.body.includes('## Code Review') || comment.body.includes('<!-- claude-code-review -->'))
            );

            if (claudeComment) {
              console.log(`Found existing Claude review comment: ${claudeComment.id}`);
              core.exportVariable('CLAUDE_COMMENT_ID', claudeComment.id);
              core.setOutput('CLAUDE_COMMENT_ID', claudeComment.id);
            } else {
              console.log('No existing Claude review comment found');
              core.exportVariable('CLAUDE_COMMENT_ID', '0');
              core.setOutput('CLAUDE_COMMENT_ID', '0');
            }

      - name: Run Claude Code Review
        if: steps.check-changes.outputs.skip-review != 'true'
        id: claude-review-action
        uses: anthropics/claude-code-action@v1
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          GITHUB_PAT: ${{ secrets.CLAUDE_REVIEW_PAT }}
          CLAUDE_COMMENT_ID: ${{ env.CLAUDE_COMMENT_ID }}
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ steps.app-token.outputs.token }}
          bot_id: ${{ vars.APP_BOT_ID }}
          bot_name: ${{ vars.APP_BOT_NAME }}
          allowed_bots: "*"
          show_full_output: true
          use_sticky_comment: true
          claude_args: |
            --allowedTools "mcp__github__pull_request_read,mcp__github__get_pull_request,mcp__github__get_pull_request_diff,mcp__github__get_pull_request_files,mcp__github__get_pull_request_status,mcp__github__get_pull_request_review_comments,mcp__github__list_commits,mcp__github__get_commit,mcp__github__get_issue_comments,mcp__github__add_comment_to_pending_review,mcp__github__pull_request_review_write,mcp__github__create_pending_pull_request_review,mcp__github__add_issue_comment,mcp__github_inline_comment__create_inline_comment,mcp__github_comment__update_claude_comment,mcp__github__get_job_logs,mcp__github__submit_pending_pull_request_review,Bash(gh:*),Bash(git:*),Bash(jq:*),Bash(cat:*),Bash(echo:*),Bash(bash .github/scripts/minimize-review-comment.sh:*),Bash(bash .github/scripts/minimize-all-reviews.sh:*),Bash(bash .github/scripts/resolve-thread.sh:*),Read,Glob,Grep,Write(/tmp/**)"
          prompt: |
            # Pull Request Context

            **Repository:** ${{ github.repository }}
            **PR Number:** ${{ github.event.pull_request.number }}
            **PR Title:** ${{ github.event.pull_request.title }}
            **Base Branch:** ${{ github.base_ref }}
            **Head Branch:** ${{ github.head_ref }}
            **Current Commit:** ${{ github.event.pull_request.head.sha }}
            **PR Description:**
            ${{ github.head_ref == 'changeset-release/main' && '(Skipped - auto-generated changelog for release PR)' || github.event.pull_request.body }}

            ---

            # Your Mission

            You are an expert code reviewer for this repository. Review the PR changes thoughtfully and help improve code quality through constructive feedback.

            **The PR branch is already checked out** in the current working directory.

            ---

            # Step 1: Gather Context

            ## Available Tools

            **MCP Tools** (preferred for data access):
            - Use these for reading PR data, commits, comments, etc.
            - More reliable than CLI parsing
            - Structured JSON responses
            - MCP tools use the GitHub App token which has full permissions
            - **Exception:** For check runs, use `gh api` (see section 1.3) - the MCP `get_status` method queries the legacy status API which is empty

            **Helper Scripts** (.github/scripts/):
            - Ready-to-use scripts for complex review management operations
            - Call via bash interpreter (scripts are not executable):
              - `bash .github/scripts/resolve-thread.sh <comment_id> <pr_number> <commit_sha> [repo_owner] [repo_name]` - Reply to thread and mark as resolved (COMMONLY USED)
              - `bash .github/scripts/minimize-review-comment.sh <comment_id> <commit_sha> [repo_owner] [repo_name]` - Minimize a specific old review comment as outdated (RARELY NEEDED - sticky comments auto-update)
              - `bash .github/scripts/minimize-all-reviews.sh <pr_number> <current_sha> [bot_login] [repo_owner] [repo_name]` - Minimize all old review summaries (RARELY NEEDED - sticky comments auto-update)
            - Use when MCP tools + simple bash can't accomplish the task
            - Repo owner/name default to ${{ github.repository_owner }}/${{ github.event.repository.name }} if not specified
            - **Note:** With sticky comments enabled, you rarely need to minimize anything
            - **Tokens:** Helper scripts automatically use `GITHUB_PAT` for operations requiring special permissions (resolving/minimizing threads)

            ---

            Use MCP tools for structured data access (preferred over bash):

            ## 1.1 Get PR Details
            ```
            mcp__github__pull_request_read(
              method: "get",
              owner: "${{ github.repository_owner }}",
              repo: "${{ github.event.repository.name }}",
              pullNumber: ${{ github.event.pull_request.number }}
            )
            ```

            ## 1.2 Get Changed Files
            ```
            mcp__github__pull_request_read(
              method: "get_files",
              owner: "${{ github.repository_owner }}",
              repo: "${{ github.event.repository.name }}",
              pullNumber: ${{ github.event.pull_request.number }}
            )
            ```

            **Note on large responses:** If MCP tools return errors about response size (>25000 tokens), use alternative approaches:
            - For large file lists: Use `gh api` piped to `jq` to filter fields (avoid `--jq` flag due to shell escaping issues)
            - For large comment threads: Use `gh api` with pagination (`--paginate`) piped to `jq` for filtering
            - For file diffs: Use `mcp__github__get_pull_request_diff` or `git diff` commands instead

            ## 1.3 Check Validation Results
            All validation checks have already run before this review. Check their status by filtering to only the checks we care about:

            ```bash
            gh api repos/${{ github.repository }}/commits/${{ github.event.pull_request.head.sha }}/check-runs | \
              jq --argjson names '["PR Title Validation","Conventional Commits","Code Quality","Tests"]' \
              '.check_runs[] | select([.name] | inside($names)) | {name, status, conclusion, details_url}'
            ```

            This filters to only the validation checks we care about:
              - **PR Title Validation** - Ensures PR title follows conventional commits
              - **Conventional Commits** - Validates all commit messages
              - **Code Quality** - Biome linting and formatting
              - **Tests** - Full test suite execution (includes shellcheck)

            Excludes irrelevant checks like "Validation" (orchestration), "Cleanup Checks", and "Claude Code Review" itself.

            **Note:** Do NOT use `mcp__github__pull_request_read(method: "get_status")` - it queries the legacy status API which is empty. This repository uses the modern check runs API.

            **Important:**
            - Checks can pass (success), fail (failure), or be skipped (neutral) - all are valid outcomes
            - Report the status of each check regardless of conclusion
            - If any checks are still running (status: "in_progress"), note that in your review
            - Consider validation results when prioritizing review feedback

            ## 1.4 Get Existing Review Comments
            ```
            mcp__github__pull_request_read(
              method: "get_review_comments",
              owner: "${{ github.repository_owner }}",
              repo: "${{ github.event.repository.name }}",
              pullNumber: ${{ github.event.pull_request.number }}
            )
            ```
            Filter for your comments (author.login == "${{ vars.APP_BOT_NAME }}")

            ## 1.5 Get Previous Top-Level Comments
            ```
            mcp__github__get_issue_comments(
              owner: "${{ github.repository_owner }}",
              repo: "${{ github.event.repository.name }}",
              issue_number: ${{ github.event.pull_request.number }}
            )
            ```
            Filter for your comments (user.login == "${{ vars.APP_BOT_NAME }}")

            ## 1.6 Detect Force-Pushes

            **Method 1: Using MCP tools (preferred)**
            ```
            # List all commits in the PR
            mcp__github__list_commits(
              owner: "${{ github.repository_owner }}",
              repo: "${{ github.event.repository.name }}",
              sha: "${{ github.head_ref }}"
            )

            # Check if a specific commit exists (if you have SHAs from previous reviews)
            mcp__github__get_commit(
              owner: "${{ github.repository_owner }}",
              repo: "${{ github.event.repository.name }}",
              sha: "commit-sha-from-previous-review"
            )
            ```

            **Method 2: Using git (fallback)**
            ```bash
            git log --all --oneline -30
            ```

            **Detection logic:**
            - Look for your previous review comments that mention specific commit SHAs
            - Try to fetch those commits using `mcp__github__get_commit`
            - If commits return 404 ‚Üí force-push occurred, inline comments are orphaned

            ---

            # Step 2: Determine Review Strategy

            ## If Force-Push Detected:

            **DO NOT create multiple new reviews.** Instead:

            1. **Update your existing sticky comment** (if one exists) using `mcp__github_comment__update_claude_comment`
            2. In the updated comment:
               - State: "üîÑ Branch was force-pushed (previous review at commit [old-sha], now at ${{ github.event.pull_request.head.sha }})"
               - Note: "Previous inline comments are orphaned and can be ignored"
               - Provide a fresh, comprehensive review of the current state
            3. Only create NEW inline comments for issues in the current code
            4. Do NOT reference or try to update orphaned inline comments

            ## If No Force-Push (Normal Update):

            ### For Previously Reported Issues:

            Check if your inline comments are still relevant by:
            1. Reading the file at the line mentioned in your comment
            2. Checking if the issue still exists

            **If fixed:** Reply to the existing review comment thread and mark as resolved:

            ```bash
            bash .github/scripts/resolve-thread.sh <comment_id> ${{ github.event.pull_request.number }} ${{ github.event.pull_request.head.sha }}
            ```

            Replace `<comment_id>` with the actual numeric comment ID from the review comment.

            **If still broken:** Reply to the existing thread (do not mark as resolved):
            ```bash
            gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/comments/<comment_id>/replies \
              -f body="‚ö†Ô∏è This issue persists at commit ${{ github.event.pull_request.head.sha }}."
            ```

            Replace `<comment_id>` with the actual numeric comment ID.

            ### For New Issues:
            - Create pending review first: `mcp__github__pull_request_review_write(method: "create", event: omitted for pending)`
            - Add inline comments: `mcp__github__add_comment_to_pending_review`
            - Submit review when done: `mcp__github__pull_request_review_write(method: "submit_pending")`

            ### Manage Summary Comments:

            **IMPORTANT - Sticky Comment Feature:**
            - This workflow uses sticky comments - your main review comment is automatically updated in place
            - The sticky comment ID is available in the environment variable `CLAUDE_COMMENT_ID` (0 if this is the first review)
            - **CRITICAL:** Include `<!-- claude-code-review -->` at the start of your main review comment (after the heading) so it can be identified and updated
            - **DO NOT minimize the sticky comment** - it will be updated automatically
            - Only minimize OTHER old review comments (e.g., from before sticky comments were enabled)

            **Main review comment format:**
            ```markdown
            # Code Review
            <!-- claude-code-review -->

            **Current Commit:** abc1234

            ## Summary
            ...your review content...
            ```

            **If you need to minimize old non-sticky comments (RARE):**

            ```bash
            bash .github/scripts/minimize-all-reviews.sh ${{ github.event.pull_request.number }} ${{ github.event.pull_request.head.sha }}
            ```

            This automatically excludes the sticky comment (ID: ${{ env.CLAUDE_COMMENT_ID }}) and minimizes only old review comments.

            **In most cases, you should NOT need to minimize anything** - just update the sticky comment.

            **Only post new summary when:**
            - Significant new changes warrant fresh analysis
            - All previous issues are resolved (final approval)
            - This is your first review of this PR
            - Force-push occurred (major rewrite)

            ---

            # Step 3: What to Review

            ## Code Quality
            - Follow patterns in [CLAUDE.md](CLAUDE.md)
            - Check for proper types (no `any` usage - see CLAUDE.md strict typing rules)
            - Verify naming conventions (lowercase filenames per CLAUDE.md)
            - Look for code duplication or refactoring opportunities

            ## Correctness & Safety
            - Logic errors or edge cases
            - Error handling
            - Security concerns
            - Performance issues

            ## Testing
            - Test coverage for new code
            - Test quality and edge cases

            ## Positive Observations
            - Acknowledge well-written code
            - Note good practices being followed
            - Celebrate improvements

            **Be constructive:** Suggest improvements, not just problems. Explain "why" behind suggestions.

            ---

            # Step 4: Post Your Review

            ## Workflow:

            1. **Check for existing review comments** from you
            2. **Check for force-push** (compare commit SHAs)
            3. **If force-push detected:**
               - Your sticky comment will be automatically updated in place
               - Don't try to update orphaned inline comments
            4. **If normal update:**
               - **Reply to and resolve** inline comment threads when issues are fixed
               - Reply to threads that still have issues (do not mark as resolved)
               - Create new inline comments for new issues
               - Your main review comment will be automatically updated via sticky comment feature
            5. **Use structured review workflow:**
               - Create pending review
               - Add all inline comments
               - Submit review with summary
            6. **If you encounter errors:**
               - Permission errors (file access, tool execution, etc.)
               - Tool failures (MCP tools, gh CLI, helper scripts)
               - API errors or rate limits
               - **Include a note in your review** mentioning what failed so maintainers can investigate

            ## Comment Quality Rules

            1. **Always verify current commit SHA** before posting
            2. **Reply to and resolve threads when fixed** - Confirm fixes with a reply and mark the thread as resolved
            3. **DON'T minimize the sticky comment** - It auto-updates in place (only minimize old non-sticky comments if needed)
            4. **Use MCP tools** for creating/updating comments (preferred)
            5. **Fall back to `gh api`** for replying to threads
            6. **Be efficient** - one clear comment beats many scattered ones
            7. **Be kind** - focus on the code, not the person
            8. **Track commit SHAs** - mention current SHA in your summary for force-push detection
            9. **Report tool/permission errors** - If you encounter permission errors, tool failures, or script errors during the review, mention them in your review comment so the maintainers are aware

            ---

            # Final Notes

            - **Current commit being reviewed:** ${{ github.event.pull_request.head.sha }}
            - **Always mention this SHA** in your summary comment
            - **Sticky comment feature is enabled** - your main review comment updates automatically
            - **Don't minimize the sticky comment (ID: ${{ env.CLAUDE_COMMENT_ID }})** - only minimize other old comments if absolutely necessary

            ## Critical Behaviors for Clean Review History:

            1. **Reply to and resolve fixed inline comments** - Confirm fixes with clear replies and mark threads as resolved
            2. **Use the sticky comment** - Your main review updates automatically, don't create duplicates
            3. **Avoid review spam** - PR conversations should be clean and easy to follow

      - name: Complete check - Review skipped
        if: always() && steps.check-changes.outputs.skip-review == 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // Retry helper for transient GitHub API errors
            async function updateCheckWithRetry(updateParams, maxRetries = 5) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await github.rest.checks.update(updateParams);
                } catch (error) {
                  const is500Error = error.status >= 500 && error.status < 600;
                  const shouldRetry = is500Error && attempt < maxRetries;

                  if (shouldRetry) {
                    const delayMs = Math.min(1000 * Math.pow(2, attempt - 1), 16000);
                    console.log(`Attempt ${attempt} failed with ${error.status} error. Retrying in ${delayMs}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                  } else {
                    throw error;
                  }
                }
              }
            }

            const checkRunId = process.env.CHECK_RUN_ID;
            await updateCheckWithRetry({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: checkRunId,
              status: 'completed',
              conclusion: 'neutral',
              output: {
                title: 'Review skipped',
                summary: 'Pull request only contains version bumps, changelog updates, and/or deleted changeset files. No code review needed.'
              }
            });

      - name: Complete check - Review completed
        if: always() && steps.check-changes.outputs.skip-review != 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // Retry helper for transient GitHub API errors
            async function updateCheckWithRetry(updateParams, maxRetries = 5) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await github.rest.checks.update(updateParams);
                } catch (error) {
                  const is500Error = error.status >= 500 && error.status < 600;
                  const shouldRetry = is500Error && attempt < maxRetries;

                  if (shouldRetry) {
                    const delayMs = Math.min(1000 * Math.pow(2, attempt - 1), 16000);
                    console.log(`Attempt ${attempt} failed with ${error.status} error. Retrying in ${delayMs}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                  } else {
                    throw error;
                  }
                }
              }
            }

            const checkRunId = process.env.CHECK_RUN_ID;
            const reviewResult = '${{ steps.claude-review-action.outcome }}';

            const conclusion = reviewResult === 'success' ? 'success' :
                              reviewResult === 'failure' ? 'failure' :
                              'neutral';

            const title = reviewResult === 'success' ? 'Review completed' :
                         reviewResult === 'failure' ? 'Review failed' :
                         'Review completed with warnings';

            await updateCheckWithRetry({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: checkRunId,
              status: 'completed',
              conclusion: conclusion,
              output: {
                title: title,
                summary: 'Claude Code Review has completed. Check the pull request comments for detailed feedback.'
              }
            });

  cleanup-checks:
    name: Cleanup Checks
    needs: [validate, claude-review]
    runs-on: ubuntu-latest
    if: always()
    permissions:
      checks: write
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          permission-checks: write

      - name: Resolve in-progress checks as neutral
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // Retry helper for transient GitHub API errors
            async function updateCheckWithRetry(updateParams, maxRetries = 5) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await github.rest.checks.update(updateParams);
                } catch (error) {
                  const is500Error = error.status >= 500 && error.status < 600;
                  const shouldRetry = is500Error && attempt < maxRetries;

                  if (shouldRetry) {
                    const delayMs = Math.min(1000 * Math.pow(2, attempt - 1), 16000);
                    console.log(`Attempt ${attempt} failed with ${error.status} error. Retrying in ${delayMs}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                  } else {
                    throw error;
                  }
                }
              }
            }

            const checkNames = [
              'PR Title Validation',
              'Conventional Commits',
              'Code Quality',
              'Tests',
              'Claude Code Review'
            ];

            // Get all check runs for this commit
            const { data: checkRuns } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.payload.pull_request.head.sha
            });

            // Find our checks that are still in progress
            const inProgressChecks = checkRuns.check_runs.filter(check =>
              checkNames.includes(check.name) && check.status === 'in_progress'
            );

            if (inProgressChecks.length === 0) {
              console.log('No in-progress checks to clean up');
              return;
            }

            console.log(`Found ${inProgressChecks.length} in-progress check(s) to clean up`);

            // Update each in-progress check to neutral
            for (const check of inProgressChecks) {
              console.log(`Resolving check: ${check.name} (ID: ${check.id})`);

              await updateCheckWithRetry({
                owner: context.repo.owner,
                repo: context.repo.repo,
                check_run_id: check.id,
                status: 'completed',
                conclusion: 'neutral',
                output: {
                  title: 'Workflow cancelled',
                  summary: 'This check was cancelled because a newer workflow run was triggered or the workflow was manually cancelled.'
                }
              });
            }

            console.log('‚úÖ All in-progress checks resolved as neutral')
