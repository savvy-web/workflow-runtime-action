name: Sync Workflow Standard Repository Labels

# This workflow syncs labels across repositories with the "workflow: standard" custom property
# It can be triggered manually via workflow_dispatch
on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Preview changes without applying them (dry-run mode)"
        type: boolean
        default: false
        required: false
      remove_custom_labels:
        description: "Remove custom labels that don't match org defaults"
        type: boolean
        default: false
        required: false

permissions:
  contents: read

jobs:
  sync-labels:
    name: Sync Labels to Standard Repos
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Load default labels from file
        id: load-labels
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            const path = require('path');

            console.log(`üìã Loading default labels from .github/labels.json...`);

            // Read labels from local file
            const labelsPath = path.join(process.env.GITHUB_WORKSPACE, '.github/labels.json');
            const labelsContent = fs.readFileSync(labelsPath, 'utf8');
            const labels = JSON.parse(labelsContent);

            console.log(`‚úÖ Loaded ${labels.length} default labels:`);
            labels.forEach(label => {
              console.log(`  - ${label.name} (#${label.color}): ${label.description}`);
            });

            if (labels.length === 0) {
              console.log('‚ö†Ô∏è  No labels found in .github/labels.json');
            }

            return labels;

      - name: Find repositories with workflow=standard
        id: find-repos
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const org = context.repo.owner;

            console.log(`üîç Searching for repositories with custom property "workflow: standard" in ${org}...`);

            // Get all repositories with custom properties
            const { data: reposWithProps } = await github.request(
              'GET /orgs/{org}/properties/values',
              {
                org,
                headers: {
                  'X-GitHub-Api-Version': '2022-11-28'
                }
              }
            );

            // Filter for repos with workflow=standard
            const standardRepos = reposWithProps.filter(repo => {
              const workflowProp = repo.properties?.find(p => p.property_name === 'workflow');
              return workflowProp?.value === 'standard';
            });

            console.log(`‚úÖ Found ${standardRepos.length} repositories with workflow: standard`);
            standardRepos.forEach(repo => {
              console.log(`  - ${repo.repository_name}`);
            });

            if (standardRepos.length === 0) {
              console.log('‚è≠Ô∏è  No repositories to sync');
            }

            return standardRepos.map(repo => repo.repository_name);

      - name: Sync labels to repositories
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const org = context.repo.owner;
            const defaultLabels = ${{ steps.load-labels.outputs.result }};
            const repoNames = ${{ steps.find-repos.outputs.result }};
            const dryRun = ${{ github.event.inputs.dry_run == 'true' }};
            const removeCustomLabels = ${{ github.event.inputs.remove_custom_labels == 'true' }};

            if (repoNames.length === 0) {
              console.log('No repositories to process');
              return;
            }

            if (dryRun) {
              console.log('\nüîç DRY-RUN MODE: No changes will be applied\n');
            } else {
              console.log('\nüîÑ Starting label sync process...\n');
            }

            // Helper function to check rate limits
            async function checkRateLimit() {
              const { data: rateLimit } = await github.rest.rateLimit.get();
              const remaining = rateLimit.resources.core.remaining;
              const resetTime = new Date(rateLimit.resources.core.reset * 1000);

              if (remaining < 100) {
                console.log(`‚ö†Ô∏è  Rate limit low: ${remaining} requests remaining (resets at ${resetTime.toISOString()})`);
              }

              return remaining;
            }

            // Helper function to add delay between repos
            function delay(ms) {
              return new Promise(resolve => setTimeout(resolve, ms));
            }

            const summary = [];
            let repoIndex = 0;

            for (const repoName of repoNames) {
              repoIndex++;

              // Check rate limit every 10 repositories
              if (repoIndex % 10 === 0) {
                const remaining = await checkRateLimit();
                if (remaining < 50) {
                  console.log('‚è∏Ô∏è  Pausing for rate limit cooldown...');
                  await delay(60000); // Wait 1 minute
                }
              }

              // Add delay between repos (except first one)
              if (repoIndex > 1) {
                await delay(1000); // 1 second delay between repositories
              }

              console.log(`\nüì¶ Processing repository: ${repoName} (${repoIndex}/${repoNames.length})`);
              console.log('‚îÄ'.repeat(60));

              try {
                // Get existing labels for the repository
                const { data: existingLabels } = await github.rest.issues.listLabelsForRepo({
                  owner: org,
                  repo: repoName
                });

                console.log(`  Current labels: ${existingLabels.length}`);

                const existingLabelNames = new Set(existingLabels.map(l => l.name.toLowerCase()));
                const defaultLabelNames = new Set(defaultLabels.map(l => l.name.toLowerCase()));

                // Find custom labels (not in defaults)
                const customLabels = existingLabels.filter(label =>
                  !defaultLabelNames.has(label.name.toLowerCase())
                );

                console.log(`  Custom labels: ${customLabels.length}`);
                if (customLabels.length > 0) {
                  customLabels.forEach(label => {
                    console.log(`    - ${label.name} (#${label.color})`);
                  });
                }

                let created = 0;
                let updated = 0;
                let unchanged = 0;
                const errors = [];

                // Process each default label
                for (const defaultLabel of defaultLabels) {
                  const existingLabel = existingLabels.find(
                    l => l.name.toLowerCase() === defaultLabel.name.toLowerCase()
                  );

                  if (!existingLabel) {
                    // Create new label
                    const action = dryRun ? '[DRY-RUN] Would create' : 'Created';
                    try {
                      if (!dryRun) {
                        await github.rest.issues.createLabel({
                          owner: org,
                          repo: repoName,
                          name: defaultLabel.name,
                          description: defaultLabel.description,
                          color: defaultLabel.color
                        });
                      }
                      console.log(`  ‚ú® ${action}: ${defaultLabel.name}`);
                      created++;
                    } catch (error) {
                      console.error(`  ‚ùå Failed to create "${defaultLabel.name}": ${error.message}`);
                      errors.push({ label: defaultLabel.name, operation: 'create', error: error.message });
                    }
                  } else {
                    // Check if update is needed
                    const descriptionDiffers = existingLabel.description !== defaultLabel.description;
                    const colorDiffers = existingLabel.color !== defaultLabel.color;
                    const nameCasingDiffers = existingLabel.name !== defaultLabel.name;
                    const needsUpdate = descriptionDiffers || colorDiffers || nameCasingDiffers;

                    if (needsUpdate) {
                      const action = dryRun ? '[DRY-RUN] Would update' : 'Updated';
                      const changes = [];
                      if (nameCasingDiffers) changes.push(`name: "${existingLabel.name}" ‚Üí "${defaultLabel.name}"`);
                      if (descriptionDiffers) changes.push('description');
                      if (colorDiffers) changes.push(`color: #${existingLabel.color} ‚Üí #${defaultLabel.color}`);

                      try {
                        if (!dryRun) {
                          await github.rest.issues.updateLabel({
                            owner: org,
                            repo: repoName,
                            name: existingLabel.name,
                            new_name: defaultLabel.name,
                            description: defaultLabel.description,
                            color: defaultLabel.color
                          });
                        }
                        console.log(`  üîÑ ${action}: ${defaultLabel.name}`);
                        if (changes.length > 0) {
                          console.log(`     Changes: ${changes.join(', ')}`);
                        }
                        updated++;
                      } catch (error) {
                        console.error(`  ‚ùå Failed to update "${defaultLabel.name}": ${error.message}`);
                        errors.push({ label: defaultLabel.name, operation: 'update', error: error.message });
                      }
                    } else {
                      unchanged++;
                    }
                  }
                }

                // Remove custom labels if requested
                let removed = 0;
                if (removeCustomLabels && customLabels.length > 0) {
                  console.log(`\n  Removing custom labels (not in org defaults)...`);
                  for (const customLabel of customLabels) {
                    const action = dryRun ? '[DRY-RUN] Would remove' : 'Removed';
                    try {
                      if (!dryRun) {
                        await github.rest.issues.deleteLabel({
                          owner: org,
                          repo: repoName,
                          name: customLabel.name
                        });
                      }
                      console.log(`  üóëÔ∏è  ${action}: ${customLabel.name}`);
                      removed++;
                    } catch (error) {
                      console.error(`  ‚ùå Failed to remove "${customLabel.name}": ${error.message}`);
                      errors.push({ label: customLabel.name, operation: 'remove', error: error.message });
                    }
                  }
                }

                // Add to summary
                summary.push({
                  repo: repoName,
                  created,
                  updated,
                  unchanged,
                  removed,
                  custom: customLabels.length,
                  customLabels: customLabels.map(l => l.name),
                  errors: errors.length > 0 ? errors : undefined,
                  success: errors.length === 0
                });

                console.log(`\n  Summary for ${repoName}:`);
                console.log(`    ‚ú® Created: ${created}`);
                console.log(`    üîÑ Updated: ${updated}`);
                console.log(`    ‚úì Unchanged: ${unchanged}`);
                console.log(`    üóëÔ∏è  Removed: ${removed}`);
                console.log(`    üè∑Ô∏è  Custom: ${customLabels.length}`);
                if (errors.length > 0) {
                  console.log(`    ‚ùå Errors: ${errors.length}`);
                  errors.forEach(err => {
                    console.log(`       - ${err.operation} "${err.label}": ${err.error}`);
                  });
                }

              } catch (error) {
                console.error(`  ‚ùå Error processing ${repoName}: ${error.message}`);
                summary.push({
                  repo: repoName,
                  success: false,
                  error: error.message
                });
              }
            }

            // Generate final report
            console.log('\n' + '‚ïê'.repeat(60));
            if (dryRun) {
              console.log('üîç DRY-RUN COMPLETE - SUMMARY (NO CHANGES APPLIED)');
            } else {
              console.log('üìä SYNC COMPLETE - SUMMARY');
            }
            console.log('‚ïê'.repeat(60));

            const successful = summary.filter(s => s.success);
            const partiallyFailed = summary.filter(s => !s.success && s.errors && s.errors.length > 0);
            const failed = summary.filter(s => !s.success && (!s.errors || s.errors.length === 0));

            console.log(`\n‚úÖ Successfully processed: ${successful.length}/${summary.length} repositories`);
            if (partiallyFailed.length > 0) {
              console.log(`‚ö†Ô∏è  Partially failed: ${partiallyFailed.length} (completed with errors)`);
            }

            if (successful.length > 0) {
              const totalCreated = successful.reduce((sum, s) => sum + s.created, 0);
              const totalUpdated = successful.reduce((sum, s) => sum + s.updated, 0);
              const totalRemoved = successful.reduce((sum, s) => sum + s.removed, 0);
              const totalCustom = successful.reduce((sum, s) => sum + s.custom, 0);

              console.log(`\nüìà Overall Statistics:`);
              console.log(`  ‚ú® Labels ${dryRun ? 'to create' : 'created'}: ${totalCreated}`);
              console.log(`  üîÑ Labels ${dryRun ? 'to update' : 'updated'}: ${totalUpdated}`);
              if (removeCustomLabels || totalRemoved > 0) {
                console.log(`  üóëÔ∏è  Labels ${dryRun ? 'to remove' : 'removed'}: ${totalRemoved}`);
              }
              console.log(`  üè∑Ô∏è  Custom labels found: ${totalCustom}`);
            }

            // Report partial failures (repos with some label errors)
            if (partiallyFailed.length > 0) {
              console.log(`\n‚ö†Ô∏è  Repositories with partial failures:`);
              partiallyFailed.forEach(repo => {
                console.log(`\n  ${repo.repo} (${repo.errors.length} errors):`);
                repo.errors.forEach(err => {
                  console.log(`    ‚ùå ${err.operation} "${err.label}": ${err.error}`);
                });
              });
            }

            if (failed.length > 0) {
              console.log(`\n‚ùå Failed repositories: ${failed.length}`);
              failed.forEach(f => {
                console.log(`  - ${f.repo}: ${f.error}`);
              });
            }

            // Report repositories with custom labels
            const reposWithCustomLabels = successful.filter(s => s.custom > 0);
            if (reposWithCustomLabels.length > 0) {
              console.log(`\nüè∑Ô∏è  Repositories with custom labels:`);
              reposWithCustomLabels.forEach(repo => {
                console.log(`\n  ${repo.repo} (${repo.custom} custom labels):`);
                repo.customLabels.forEach(label => {
                  console.log(`    - ${label}`);
                });
              });
            }

            // Create job summary
            if (dryRun) {
              core.summary.addHeading('üîç Dry-Run Label Sync Results', 2);
              core.summary.addRaw(`\n**Mode:** Preview only (no changes applied)\n\n`);
            } else {
              core.summary.addHeading('Label Sync Results', 2);
            }
            core.summary.addRaw(`**Repositories processed:** ${summary.length}\n`);
            core.summary.addRaw(`**Successful:** ${successful.length}\n`);
            if (partiallyFailed.length > 0) {
              core.summary.addRaw(`**Partially failed:** ${partiallyFailed.length}\n`);
            }
            core.summary.addRaw(`**Failed:** ${failed.length}\n`);

            if (successful.length > 0) {
              const totalCreated = successful.reduce((sum, s) => sum + s.created, 0);
              const totalUpdated = successful.reduce((sum, s) => sum + s.updated, 0);
              const totalRemoved = successful.reduce((sum, s) => sum + s.removed, 0);

              core.summary.addHeading('Statistics', 3);
              core.summary.addRaw(`- Labels ${dryRun ? 'to create' : 'created'}: ${totalCreated}\n`);
              core.summary.addRaw(`- Labels ${dryRun ? 'to update' : 'updated'}: ${totalUpdated}\n`);
              if (removeCustomLabels || totalRemoved > 0) {
                core.summary.addRaw(`- Labels ${dryRun ? 'to remove' : 'removed'}: ${totalRemoved}\n`);
              }
            }

            // Add partial failures to summary
            if (partiallyFailed.length > 0) {
              core.summary.addHeading('Partial Failures', 3);
              partiallyFailed.forEach(repo => {
                core.summary.addRaw(`\n**${repo.repo}** (${repo.errors.length} errors):\n`);
                repo.errors.forEach(err => {
                  core.summary.addRaw(`- ‚ùå ${err.operation} \`${err.label}\`: ${err.error}\n`);
                });
              });
            }

            if (reposWithCustomLabels.length > 0) {
              core.summary.addHeading('Custom Labels Detected', 3);
              reposWithCustomLabels.forEach(repo => {
                core.summary.addRaw(`\n**${repo.repo}** (${repo.custom} custom):\n`);
                repo.customLabels.forEach(label => {
                  core.summary.addRaw(`- \`${label}\`\n`);
                });
              });
            }

            await core.summary.write();

            if (dryRun) {
              console.log('\n‚úÖ Dry-run complete! Review the summary above to see what changes would be made.');
            } else {
              console.log('\n‚úÖ Label sync complete!');
            }
